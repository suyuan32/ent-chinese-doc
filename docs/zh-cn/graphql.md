Ent 框架通过 [99designs/gqlgen](https://github.com/99designs/gqlgen) 库来支持 GraphQL， 提供了多种集成方式:
1. 通过在 Ent schema中定义的节点和边生成 GraphQL 的 schema。
2. 自动生成的“Query”和“Mutation”解析器，并提供与 [Relay framework](https://relay.dev/) 的无缝集成.
3. [Relay Cursor Connections Spec](https://relay.dev/graphql/connections.htm) 的过滤、分页（包括嵌套）和兼容支持。
4. 高效的[字段集合](tutorial-todo-gql-field-collection) 无需数据加载器即可克服 N+1 问题。
5. [事务性变更](tutorial-todo-gql-tx-mutation.md) 以确保发生故障时的一致性。

查看网站了解更多 [GraphQL tutorial](tutorial-todo-gql.mdx#basic-setup)


## 快速指南

为了在你的项目中启用 [`entgql`](https://github.com/ent/contrib/tree/master/entgql) 扩展, 你需要 `entc` (ent codegen) 包 [点此查看](./zh-cn/code-gen.md#把-entc-作为库使用). 请按照以下 3 个步骤将其启用到您的项目中:

1\. 新建一个名为 ent/entc.go 的 Go 文件，粘贴以下内容:

```go title="ent/entc.go"
// +build ignore

package main

import (
    "log"

    "entgo.io/ent/entc"
    "entgo.io/ent/entc/gen"
    "entgo.io/contrib/entgql"
)

func main() {
    ex, err := entgql.NewExtension()
    if err != nil {
        log.Fatalf("creating entgql extension: %v", err)
    }
    if err := entc.Generate("./schema", &gen.Config{}, entc.Extensions(ex)); err != nil {
        log.Fatalf("running ent codegen: %v", err)
    }
}
```

2\. 编辑`ent/generate.go`文件来执行`ent/entc.go`文件:

```go title="ent/generate.go"
package ent

//go:generate go run -mod=mod entc.go
```

请注意，使用构建标记会忽略 ent/entc.go，它由 go generate 命令通过 generate.go 文件执行。 完整示例可以在 [ent/contrib 存储库](https://github.com/ent/contrib/blob/master/entgql/internal/todo) 中找到。

3\. 为您的 ent 项目运行代码生成：

```console
go generate ./...
```

运行 codegen 后，以下附加组件将添加到您的项目中。

## Node API

创建了一个名为“ent/gql_node.go”的新文件，它实现了[中继节点接口](https://relay.dev/graphql/objectidentification.htm)。

为了在 [GraphQL 解析器](https://gqlgen.com/reference/resolvers/) 中使用新生成的 `ent.Noder` 接口，将 `Node` 方法添加到查询解析器，并查看 [ 配置](#gql-configuration) 部分以了解如何使用它。

如果您在架构迁移中使用 [Universal IDs](migrate.md#universal-ids) 选项，则 NodeType 派生自 id 值，可以按如下方式使用：

```go
func (r *queryResolver) Node(ctx context.Context, id int) (ent.Noder, error) {
    return r.client.Noder(ctx, id)
}
```

但是，如果您对全局唯一标识符使用自定义格式，则可以按如下方式控制 NodeType：

```go
func (r *queryResolver) Node(ctx context.Context, guid string) (ent.Noder, error) {
    typ, id := parseGUID(guid)
    return r.client.Noder(ctx, id, ent.WithFixedNodeType(typ))
}
```


## GQL 配置

这是 [ent/contrib/entgql/todo](https://github.com/ent/contrib/tree/master/entgql/internal/todo) 中存在的待办事项应用程序的配置示例。

```yaml
schema:
  - todo.graphql

resolver:
  # Tell gqlgen to generate resolvers next to the schema file.
  layout: follow-schema
  dir: .

# gqlgen will search for any type names in the schema in the generated
# ent package. If they match it will use them, otherwise it will new ones.
autobind:
  - entgo.io/contrib/entgql/internal/todo/ent

models:
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.IntID
  Node:
    model:
      # ent.Noder is the new interface generated by the Node template.
      - entgo.io/contrib/entgql/internal/todo/ent.Noder
```

## 分页

分页模板根据_Relay Cursor Connections Spec_ 添加分页支持。 有关中继规范的更多信息可以在其 [网站](https://relay.dev/graphql/connections.htm) 中找到。

## 连接顺序

排序选项允许我们对从连接返回的边应用排序。

### 使用说明

- 如果保留命名约定，生成的类型将自动绑定到 GraphQL 类型（请参见下面的示例）。
- 只能在输入字段（无边）上定义排序。
- 排序字段通常应 [indexed](./zh-cn/schema-indexes.md) 以避免全表数据库扫描。
- 分页查询可以按单个字段排序（没有 order by ... then by ... 语义）。

### 样例

让我们回顾一下向现有 GraphQL 类型添加排序所需的步骤。 代码示例基于可在 [ent/contrib/entql/todo](https://github.com/ent/contrib/tree/master/entgql/internal/todo) 中找到的待办事项应用程序。

### 在 ent/schema 中定义排序(order)字段

可以在 ent 的任何可比较字段上定义排序，方法是使用 entgql.Annotation 对其进行注释。 请注意，给定的 OrderField 名称必须与其在 graphql 架构中的枚举值匹配。

```go
func (Todo) Fields() []ent.Field {
    return []ent.Field{
        field.Time("created_at").
            Default(time.Now).
            Immutable().
            Annotations(
                entgql.OrderField("CREATED_AT"),
            ),
        field.Enum("status").
            NamedValues(
                "InProgress", "IN_PROGRESS",
                "Completed", "COMPLETED",
            ).
            Annotations(
                entgql.OrderField("STATUS"),
            ),
        field.Int("priority").
            Default(0).
            Annotations(
                entgql.OrderField("PRIORITY"),
            ),
        field.Text("text").
            NotEmpty().
            Annotations(
                entgql.OrderField("TEXT"),
            ),
    }
}
```
这就是所有需要的模式(schema)更改，确保运行 go generate 来应用它们。

### 在 GraphQL 模式中定义排序类型

接下来我们需要在 graphql schema 中定义排序类型：

```graphql
enum OrderDirection {
  ASC
  DESC
}

enum TodoOrderField {
  CREATED_AT
  PRIORITY
  STATUS
  TEXT
}

input TodoOrder {
  direction: OrderDirection!
  field: TodoOrderField
}
```
请注意，命名必须采用 `<T>OrderField` / `<T>Order` 的形式，以便 `autobind` 生成的实体类型。 或者 [@goModel](https://gqlgen.com/config/#inline-config-with-directives) 指令可用于手动类型绑定。

### Adding orderBy argument to the pagination query
```graphql
type Query {
  todos(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: TodoOrder
  ): TodoConnection!
}
```
这就是 GraphQL schema更改的全部内容，让我们运行“gqlgen”代码生成。

### 更新底层解析器

转到 Todo 解析器并更新它以将 orderBy 参数传递给 .Paginate() 调用：

```go
func (r *queryResolver) Todos(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TodoOrder) (*ent.TodoConnection, error) {
    return r.client.Todo.Query().
        Paginate(ctx, after, first, before, last,
            ent.WithTodoOrder(orderBy),
        )
}
```

### 在 GraphQL 中使用

```graphql
query {
    todos(first: 3, orderBy: {direction: DESC, field: TEXT}) {
        edges {
            node {
                text
            }
        }
    }
}
```

## 字段集合

集合模板添加了对使用预加载的 ent-edges 的自动 [GraphQL 字段集合](https://spec.graphql.org/June2018/#sec-Field-Collection) 的支持。 这意味着，如果查询要求节点及其边缘，entgql 将自动添加 [`With<E>`](./zn-cn/eager-load.mdx#api) 步骤到根查询，结果，客户端将执行常量 对数据库的查询次数 - 它以递归方式工作。

例如，给出这个 GraphQL 查询：

```graphql
query {
  users(first: 100) {
    edges {
      node {
        photos {
          link
        }
        posts {
          content
          comments {
            content
          }
        }
      }
    }
  }
}
```

客户端将执行 1 个查询来获取用户，1 个查询来获取照片，另外 2 个查询来获取帖子和他们的评论（总共 4 个）。 此逻辑适用于根查询/解析器和节点 API。

### Schema 配置

为了将此选项配置为特定的边(edge)，请使用 entgql.Annotation 如下：

```go
func (Todo) Edges() []ent.Edge {
    return []ent.Edge{
        edge.To("children", Todo.Type).
            Annotations(entgql.Bind()).
            From("parent").
            // Bind implies the edge name in graphql schema is
            // equivalent to the name used in ent schema.
            Annotations(entgql.Bind()).
            Unique(),
        edge.From("owner", User.Type).
            Ref("tasks").
            // Map edge names as defined in graphql schema.
            Annotations(entgql.MapsTo("taskOwner")),
    }
}
```

### 使用和配置

GraphQL 扩展还为 `gql_edge.go` 文件下的节点生成边缘解析器(edge resolvers)，如下所示：
```go
func (t *Todo) Children(ctx context.Context) ([]*Todo, error) {
    result, err := t.Edges.ChildrenOrErr()
    if IsNotLoaded(err) {
        result, err = t.QueryChildren().All(ctx)
    }
    return result, err
}
```

但是，如果您需要手动显式编写这些解析器，则可以将 [`forceResolver`](https://gqlgen.com/master/config#inline-config-with-directives) 选项添加到您的 GraphQL Schema：
```graphql
type Todo implements Node {
  id: ID!
  children: [Todo]! @goField(forceResolver: true)
}
```

然后，您可以在您的类型解析器上实现它。

```go
func (r *todoResolver) Children(ctx context.Context, obj *ent.Todo) ([]*ent.Todo, error) {
    // Do something here.
    return obj.Edges.ChildrenOrErr()
}
```

## 枚举实现

枚举模板为 ent 生成的枚举实现 MarshalGQL/UnmarshalGQL 方法。

## 事务的变更（Transactional Mutations）

`entgql.Transactioner` 处理程序执行事务中的每个 GraphQL 变更。 解析器的注入客户端是一个[事务性 ent.Client](transactions.md#transactional-client)。 因此，不需要更改使用 ent.Client 的代码。 要使用它，请按照下列步骤操作：

1\. 在 GraphQL 服务器初始化中，使用 entgql.Transactioner 处理程序，如下所示：

```go
srv := handler.NewDefaultServer(todo.NewSchema(client))
srv.Use(entgql.Transactioner{TxOpener: client})
```

2\. 然后，在 GraphQL 突变中，使用来自上下文的客户端，如下所示：
```go
func (mutationResolver) CreateTodo(ctx context.Context, todo TodoInput) (*ent.Todo, error) {
    client := ent.FromContext(ctx)
    return client.Todo.
        Create().
        SetStatus(todo.Status).
        SetNillablePriority(todo.Priority).
        SetText(todo.Text).
        SetNillableParentID(todo.Parent).
        Save(ctx)
}
```

## 例子

[ent/contrib](https://github.com/ent/contrib) 目前包含几个示例：
1. 带有数字 ID 字段的简单 [Todo App](https://github.com/ent/contrib/tree/master/entgql/internal/todo) 的完整 GraphQL 服务器
2. 同1中的[Todo App](https://github.com/ent/contrib/tree/master/entgql/internal/todouuid)，但ID字段为UUID类型
3. 1和2中相同的[Todo App](https://github.com/ent/contrib/tree/master/entgql/internal/todopulid)，但前缀为[ULID](https://github. com/ulid/spec) 或 `PULID` 作为 ID 字段。 此示例通过在 ID 前加上实体类型来支持中继节点 API，而不是在 [Universal IDs](migrate.md#universal-ids) 中使用 ID 空间分区。
---

请注意，此文档正在开发中。 所有代码部分都位于 [ent/contrib/entgql](https://github.com/ent/contrib/tree/master/entgql) 中，待办事项应用程序的示例可以在 [ent/contrib/entgql] 中找到 /todo](https://github.com/ent/contrib/tree/master/entgql/internal/todo)。